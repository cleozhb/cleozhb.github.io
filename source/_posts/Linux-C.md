---
title: Linux C
date: 2018-12-19 15:30:16
tags: [Linux, C]
---

# 宏和typedef
![图片](1.png)

<!--more-->

这个过程其实经历了4步
第一步预处理gcc -o helloworld.i helloworld.c -E用这个命令使得编译器只进行第一步，得到一个.i文件。打开helloworld.i文件可以看到的是将头文件展开后的结果。

在预处理阶段，代码中所有的宏会被替换成相应的值。在这个过程中，编译器将宏中定义的值视为字符串，而不是数字。在替换过程中只是单纯的将字符串替换到了代码中。宏的本质就是发生在预处理阶段的单纯的字符串替换。所以在使用宏定义函数的时候要加上括号，以防运算优先级在替换后被改变。比如，如果ADD不加括号，被替换之后就会变成注释掉的那行代码，这显然不是我们的本意。
![图片](2.png)
宏的好处在于不考虑参数的类型，比如上面我们传入浮点型，那就可以计算浮点型出来，。都看作字符串来处理。

除了宏，在预处理阶段还有一个功能是条件编译，可以按照不同的条件编译不同的程序部分，从而产生不同的目标代码文件，对于程序的移植和调试很有用。


typedef要满足C语法,语句结尾有封号
define不用满足C语法
define 的作用域是全局的，就是说在函数体内部定义了，在外面依然可以使用，而typedef不一样;typedef只能在函数内部使用了。
typedef 是给类型定义别名
typedef int *p;的含义就是给int *这个类型定义了一个别名p.
用typedef定义的在预处理之后生成的.i文件中原来的名称并不会被替换掉，而define被替换掉了。
size_t是系统给我们定义的一种类型，全称为typedef unsigned long size_t
size_t具有更好的可读性
比如结构体的声明
typedef struct student{
……
}stu_t;
以后就可以用stu_t xxx;来定义结构体了。

# 联合体
共用体 union 的成员的地址和它本身的地址是同一个;union的长度等于它的成员变量中最长的那个，一次定义只能使用其中的一个成员变量;   从下图的报错可以看出，d1.b已经不可以使用了。
![图片](3.png)![图片](4.png)
![图片](5.png)

# 动态链表
![图片](6.png)![图片](7.png)
```
#include <stdio.h>
#include <malloc.h>

struct weapon{
  int price;
  int atk;
  struct weapon *next;
};

struct weapon* create()
{
    struct weapon *head;
    struct weapon *p1,*p2;
    int n=0;
    p1 = p2 = (struct weapon*)malloc(sizeof(struct weapon));
    scanf("%d,%d",&p1->price,&p1->atk);
    head = NULL;
    while(p1->price!=0)
    {
        n++;
    if(n==1) head = p1;
    else{
        p2->next = p1;
    }
    p2 = p1;
    p1 = (struct weapon*)malloc(sizeof(struct weapon));
    scanf("%d,%d",&p1->price,&p1->atk);
    }
    p2->next = NULL;
    return (head);
}

int main(){
/*
  struct weapon a,b,c,*head;
  a.price = 100;
  a.atk = 100;
  b.price = 200;
  b.atk = 200;
  c.price = 300;
  c.atk = 300;
  head = &a;
  a.next = &b;
  b.next = &c;
  c.next = NULL;

struct weapon *p;
p = head;
while(p!=NULL)
{
    printf("%d,%d\n",p->atk,p->price);
    p=p->next;
}
*/
    struct weapon* p;
    p = create();
    while(p->next!=NULL)
    {
    printf("%d,%d\n",p->price,p->atk);
    p=p->next;
    }
    printf("%d,%d\n",p->price,p->atk);

    return 0;
}
```
# 位运算符
![图片](8.png)
 
& 迅速清零，保留指定位，判断奇偶性a&1 =1 奇数，a=0 偶数
| 设置指定位置 
^ 定位反转 a = a^0xFF;数值交换 
![图片](9.png)![图片](10.png)

<<实现2倍乘的过程
>>如果符号位为0,左边补0,如果符号位为1,左边补1;实现除数为2的快速运算
```
#include <stdio.h>
int main(){
  //& | ^ ~ << >>
  
  int a=4;//00000000 00000000 00000000 00000100
  int b=7;//00000000 00000000 00000000 00000111
             //00000000 00000000 00000000 00000100
  int c = a&b;
  printf("c=%d\n",c);
  
  
  int d = a|b;
  printf("d=%d\n",d);
  
  //a=a|0xFF;
  //printf("a=%d\n",a);
  
  
  a = a^b;
  printf("a=%d\n",a);
  b = b^a;
  printf("b=%d\n",b);
  a = a^b;
  printf("a=%d\n",a);
  return 0;
}
```
# 重识C语言

![图片](11.png)
C语言可以做linux嵌入式。例如cd,ls等命令都是用C语言写的。
C可以做与硬件打交道的程序，C有指针，可以直接跟内存打交道，适合硬件编程、
C语言适合做有高性能要求的应用程序，NGINX的并发量可以达到apache的10倍以上
![图片](12.png)

make可以将大型的开发项目分成若干个模块，可以很清晰快捷的整理源文件
make的内部也是使用gcc。约定用Makefile来写make文件
越往上就是最终要生成的文件，也就是Makefile文件先写最终要生成的输出文件
再写中间依赖的.o文件
![图片](13.png)
make会一个一个往下找，知道我们需要的所有的文件都有了，最终编译最上面的那个项目文件
用Makefile文件第二次编译时已经编译过的文件就不会再编译了，只会编译更改的文件。这样就节省了时间。没有修改的文件生成的目标文件都一样只要最后一次性连接起来就可以了。

用<>的头文件表示是操作系统预装的库，会在系统目录下查找，如果是项目里的源代码，通常是在项目路径中的，直接写文件名表示在当前目录里查找文件。 可以直接包含.c文件，这样就相当于直接将.c文件中的代码粘贴过来。这时候在用gcc编译的时候就不用写被包含的文件名了。但是这样当项目很大时还是相当于将很多代码放在了一个文件当中，无法做到分开编译。所以最好是函数的定义和声明分开写在两个文件中，这样main函数中引用头文件就可以了。这样就可以进行分开编译了。

# C语言main函数详解
程序和操作系统是怎么交互的呢？
C语言main函数是有两个参数的，第一个参数是int argv,第二个参数是char* argc[]
C在运行的时候可以与操作系统进行交互

在linux中可以用&&连接两条命令，只有&&前面的函数的返回值是0的时候后面的命令才会执行。0表示执行成功。
![图片](14.png)
当执行完一个命令以后用echo $? 如果输出0说明没有问题，如果输出是其他值证明程序执行失败，应用程序会返回错误码。这个错误码就是main函数的返回值。
![图片](15.png)
上面的截图表示将main函数的返回值改为101,则操作系统认为第一个操作./main2并没有正常退出，所以ls命令不执行。
所以C语言的return 0是有含义的并不是我们乱写的！0表示正常退出。
```
#include<stdio.h>
#include "max.h"
#include "min.h"

int main(int argc, char* argv[])
{
        int a =atoi(argv[1]);
        int b =atoi(argv[2]);
        int n = max(a,b);
        int s = min(a,b);
        printf("argv[0] is %s\n",argv[0]);
        printf("argc is %d \n",argc);
        printf("max val is %d \n",n);
        printf("min val is %d \n",s);
        return 0;
}
```
argc表示输入的参数个数，argv表示每个输入是什么。argv[0]表示执行文件名
后面用argv[1]等表示真正的输入参数，atoi是array to int 的缩写，表示将char* 转int，是C语言库函数中提供的方法。
![图片](16.png)

# C语言标准输入输出流以及错误流
stdio.h
![图片](17.png)

这个最简单的程序，当启动时系统启动一个进程，启动进程的同时stdio.h就会提供一系列的指针，这个指针是指向资源的指针，因为linux是将所有的东西包括外设都看成是文件，所以启动一个应用程序的时候，系统会认为我们这个应用程序要与文件交互，会默认帮我们传递三个文件，分别为stdin,stdout,stderr，这几个文件就是标准输入流，输出流错误流，系统认为任何一个应用程序都有可能会与文件或者设备进行交互，stdin负责输入数据，标准的输入设备是键盘，其实标准的输入设备是可以更改的，通过流的重定向可以让不同的输入设备来输入数据。所以输入流是给程序输入数据用的。stdout也是一个文件，标准的输出流默认指的是显示器终端。默认键盘接收输入数据，显示器接收输出数据。
```
printf是对fprint+文件句柄的封装
printf("please input the value: \n");
等价于
fprint(stdout,"please input the value: \n");
此处stdout可以换成其他任何文件，但是默认写stdout就是指向终端屏幕来输出。

同理scanf也是对fscanf句柄的封装.
int a;
scanf("%d",&a);
等价于
fscanf(stdin,"%d",&a);

#include <stdio.h>
int main()
{
  printf("please input the value i: \n");
  int i,j;
  scanf("%d",&i);
  printf("please input the value j: \n");
  scanf("%d",&j);
  if(0!=j)
  {
    printf("%d/%d= %d\n",i,j,i/j);
  }
  else
  {
    fprintf(stderr,"j!=0\n");
    return 1;
  }
  return 0;
}
下面是标准错误流，要求返回值不能等于0 
fprintf(stderr,"j!=0\n");
```
>>表示将标准输出流重定向

![图片](18.png)
上面的图片表示将输出流重定向到cio.txt标准输入流仍然是键盘。 
使用>>重定向时重定向的文件是采用的追加模式。
使用>重定向时重定向的文件是采用的覆盖模式。
1>true.txt和2>false.txt表示分别将正确的输出结果和错误的输出结果导入到两个不同的文件中。
![图片](19.png)
# C 指针
### 计算机中内存是怎么工作的
计算机中内存的最小单位是：字节（Byte）
一个字节是8个二进制位 1Byte = 8bit
为什么计算机要用二进制来表示呢？电子计算机是又逻辑电路元件来组成的，由于电路的状态只有两种，一种是高电位，高电位电路是通的记为1，低电位电路不通记为0。
![图片](20.png)
 电只有通和断这两种形式，所以用二进制表示。由于2进制表示时要用很长的一串数字，太占篇幅了，所以计算机中为了方便表示，还有一种表示方法是十六进制。给人看用十进制表示。二进制和十六进制之间正好有个规律，一个十六进制的数字可以表示4位二进制的数字。
![图片](21.png)
![图片](22.png)
 ![图片](23.png)
### 内存是什么
内存由操作系统统一管理，一个字节有8个二进制位，在计算机中插2个2G的内存条和插一个4G的内存条是等效的，计算机将内存看成一个整体来计算内存的大小。内存条不是你想插多少就插多少的。32位（指给内存的编号只能编到32个二进制位）操作系统最大使用2^32 = 4G的内存。因为在32位的平台上，地址总线是32位，也就是操作系统的寻址空间是32位。CPU的指令通过地址总线来寻址，它的信号也是电流信号，要么是1，要么是0.这32个位置有不同的组合，地址总线可以存在多种状态。
![图片](24.png)
一个编号就可以代表一个内存的最小存储单位1个字节，那么一共可以存储
2^32字节 
= 1024*1024*1024*2字节
= 1024*1024*4K
= 1024×4M
= 4G
操作系统会对所有的内存进行管理，对内存进行编号，编号 = 唯一的内存字节的地址
![图片](25.png)
一个字节可以存放8个二进制位。下图是什么都没有写的计算机内存。每个内存地址都有编号，由操作系统管理。
最高位的地址编号,用十六进制写就是0xffffffffffffffff(16个f)
最低位就是内存中第一个编号的地址0x0
![图片](26.png)

### 内存为什么要交给操作系统管理
因为计算机中可能要同时运行多个程序。由程序员对内存直接进行管理是不合理的。多个程序对同一个地址操作的话，这个内存该分配给哪个程序呢？  很容易产生冲突，内存的占用不确定，不需要让程序员自己管理内存。所有的应用程序都由操作系统来调用。main()就是所有函数的入口，操作系统知道入口了以后就以执行代码，程序就可以被调用了。
![图片](27.png)
由操作系统统一的管理内存，除了能给内存做编号以外，还可以给内存做一定的规划。
![图片](28.png)

![图片](29.png)
比如在64位操作系统中，它认为我们程序员使用的内存只要有前面的48位就足够了。所以只要从0x7fffffffffffffff以下的内存地址空间给我们用户写的应用程序用就可以了。这些内存是我们程序员可以使用的内存空间，上面的那部分给操作系统使用。这样就可以将操作系统的内存与用户内存区分开，应用程序管理更合理。
![图片](30.png)
![图片](31.png)
![图片](32.png)
### 计算机的内存是如何来规划的
![图片](33.png)
最高位是操作系统内存，下面的48位是用户应用程序使用的内存，这些内存空间为了方便管理又进行了分片。比如说最低位通常为代码段，也就是我们写的一些实际应用的函数，编译之后存到磁盘，一旦运行这个应用程序，源代码编译之后的二进制数据就会加载到内存当中，这些计算机指令就会放在最低位的代码段。
我们可能会在程序中声明一些全局变量或者常量，比如const int i = 20;这些就会放在数据段。数据段的内存地址编号通常会大于代码段。代码段和数据段都是操作系统先规划好的，除此之外还有对内存，栈内存，以及自由可分配内存。通常情况下不会把计算机内存全部占满，绿色区域就是操作系统可以给应用程序动态分配的内存。这个空间越大，应用程序可以调用的资源就越多。
栈，从main函数开始调用的函数依次往下压。

### 栈，堆，数据段，代码段的作用
```
#include <stdio.h>
int global = 0;
int rect(int a,int b)
{
  static int count = 0;
  count++;
  global++;
  int s = a*b;
  return s;
}
int quadrate(int a)
{
  static int count = 0;
  count++;
  global++;
  int s = rect(a,a);
  return s;
}
int main()
{
  int a = 3;
  int b = 4;
  int *pa = &a;
  int *pb = &b;
  int *pglobal = &global;
  int (*pquadrate)(int a) = &quadrate;
  int s = quadrate(a);
  printf("%d\n",s);
}
```
程序可以调试是因为程序被编译成机器码了，计算机就可以识别这种代码，在运行的时候被加载到内存中。在内存中保存的都是二进制，写的程序被编译后就是0101的二进制码了，被加载到代码段中。C语言语法不允许我们直接操作代码段，也不允许我们直接操作内存，应为你有可能操作到操作系统内存或者其他应用程序使用的内存，这都是不合法的。程序在运行的过程中，除了代码编译后存在代码段以外， 还有一个地方可以保存当前程序运行状态。比如当前调用哪个函数，当前调用运行到哪一行。
![图片](34.png)
这些信息在程序执行的过程中都要被记录下来，这个记录的地方在哪儿呢？当然也是在内存，就是记录在内存的栈中。栈记录了程序的执行状态。
### 变量的本质
变量只是一个代号而已，代表了这个内存地址空间。变量就是一个标识，它告诉CPU要到什么地方去取这个数据，或者要把数据写到什么地方去。数组名int array[2]的本质是指针常量。array只要声明了就永远指向这个地址，就不能被改变了，而指针是变量，可以随时改变指向。这是数组与指针的区别，它们有一定的通用性也有差别。
![图片](35.png)
指针的本质：指针保存内存的地址。
 ![图片](36.png)
打印两个函数的地址，可以看到rect函数的地址比quadrate要小，ract函数先被加载进来，quadrate后被加载，rect的地址更小，这两个函数是连续声明的，如果将两个地址相减，得到的值就是rect函数被编译以后加载到内存中所占内存的大小。指令越多的函数所占地址空间就越多，所以这个值并不固定。一个函数包含多少指令决定了这个大小。
![图片](37.png)
上图中，a是我们声明的第一个变量，b是紧接着申请的，b的地址就是a的地址+4个字节。在C语言中一个int型占4个字节，CPU找到这个地址以后就会认为从这个地址开始4个字节是存放的a这个变量，再接下来的4个字节就是b这个变量。
b也是占4个字节，d950之后下一个变量的起始地址应该是d954呀，但是事实上是d958，这是为什么？ 这是因为编译器进行了优化，编译器为了让CPU操作指令更方便，为了提升程序的执行效率，会对源代码做一定的优化，编写之后的指令存储与我们编写代码的顺序有可能不一样。
可以看到变量s的地址是从d954开始的。这就是编译器做的优化，如果程序中申请了若干的int变量，若干的Int*，若干的double变量的话，编译器会将同一类型的变量申明放在一起。所以int a,int b,int s放在一起了。所以a的地址+4字节 = b的地址;b的地址+4个字节 = s的地址;
pa的地址 = s的地址+4字节;
pb的地址 = pa  + 8 字节(32位程序中指针占4字节，64位中占8字节，64个二进制为需要8个字节)
所以pa,pb各占8字节。
在64位操作系统中所有的指针都是8个字节。 所以pglobal = pb +8;pquadrate = pglobal + 8;
栈表示程序运行的当前状态。栈并不关心变量叫啥，当一个函数被多次调用，每个函数都是一个独立的栈，而且栈的内存都是0x7ffffff...很接近用户能用的内存中的最大内存， 
在代码段中地址是由低地址向高地址转移的，先声明的函数地址小，后声明的函数地址大;
而栈中就是相反的了。 最先分配的栈，地址最大。
![图片](38.png)
从图中可以看出，quadrate函数的地址比main函数要小。
后分配的rect函数中的s 的地址d904也比先分配的quadrate函数中的地址要小d92c。
从栈顶向下分配。
 ![图片](39.png)
静态变量(有static修饰的)count，常量，全局变量global，地址都很小0x60...，肯定不在栈的区，而是在数据段中存放。只有局部变量在栈的区域。静态变量是每个函数特有的，全局变量是所有函数共用的，由于它们都在数据段中，即使一个函数被多次调用，静态变量指向的是数据段中一个固定的地址，所以不同函数中的count是不同的count，但同一个函数不管调用多少次，指向的都是数据段中的同一个地址，这就是静态变量。

### 函数指针
指向代码块的首地址， 任何一个指针只写变量名表示这个指针指向的地址，如果想要取出地址里的东西，就要在指针前面加一个*，当指针指向的是代码块时，操作系统认为我们要调用这个函数了。函数指针可以用于使用回调函数。当你要给别人提供一个接口，即返回一些数据，但是你并不知道别人要用这些数据做什么时，可以写一个回调函数，别人只需要传入函数指针就可以用你提供的数据了。
```
#include <iostream>
#include <assert.h>
using namespace std;

int sub(int a,int b)
{
    return a+b;
}
int mul(int a,int b)
{
    return a*b;
}

int di(int x,int y)
{
    assert(y!=0);
    return x/y;
}

void test(int(*p)(int,int),int a,int b)
{
    cout<<(*p)(a,b)<<endl;
}

void main()
{
    int a=4;
    int b=2;
    test(mul,a,b);
    test(sub,a,b);
    test(di,a,b);
}
```
### 字符数组
```
#include <stdio.h>
int main()
{
  char str[] = "hello";
  char *str2 = "world";
  char str3[10];
  printf("input the value\n");
  scanf("%s",str);
//  scanf("%s",str2);不能被scanf写入
  printf("str is %s\n",str);
  printf("str2 is %s\n",str2);
  printf("str3 is %s\n",str3);
}
```
char* str2是不能被scanf写入的。
因为str2是在编译时放在代码段的，是不允许我们随意修改的。str2相当于是一个常量字符串。
因为str和str3都是分配在栈内存中，他们的地址空间应该是连续的，所以当我们用scanf改变str的值时，如果超出了str的长度，那么就会覆盖到str3，如果连str3也被沾满了，就会接着往后覆盖。这种做法是极为不安全的。
字符串都是以\0结尾的，按照循环的方式输出字符数组时不会受到\0的约束，而按照printf方式输出时，遇到\0就认为字符串结束。
![图片](40.png)
![图片](41.png)
