---
title: NVIDIA parallel computing-5
date: 2018-09-02 16:17:06
tags: CUDA
---

# Lesson5 optimizing GPU programs
1. picking good algorithms 选择时间复杂度低的算法
2. basic principles for efficiency 提高效率的基本原则
3. arch-specific detailed optimization 优化架构上的细节
4. Optimization at instruction level 指令级别的优化

 
前两个原则是优化最应该考虑的问题，能提高的加速比也是最高的;比如选择快排而不是插入排序，比如在遍历二维数组的时候按行遍历，这样可以访问内存中连续部分，减少内存访问的次数。

<!--more-->

![图片](1.png)



![图片](2.png)

对于GPU来说，首先要寻找真正适合并行的算法，例如堆排序和归并排序，虽然它们的时间复杂度都是nlogn但是，归并排序具有很好的并行性，所以一般而言，选用归并排序进行并行化。
其次，对于GPU来说访问内存是一个极为耗时的操作，往往比用来计算的时间长很多，所以合并访问全局内存和合理利用共享内存是必须要考虑的方案。

忍者级别的优化方案，可以考虑减少存储体访问冲突，优化寄存器的使用;



系统优化过程APOD


![图片](3.png)

**Analyze**: profile whole application分析整个应用程序，不仅仅是看你打算并行化的内核，而是审视整体，弄明白这个程序什么地方能够从并行化中受益，预期的收益是多少？
* where can it benefit?
* by how much?

决定一个需要并行化的代码区域，选择一个方法来进行并行化
**Parallelize **
* 选择一个并行化的方法（调用现有的库、使用openMP或OpenACC等轻量级的库、用CUDA开发一个真正并行化的算法）
* 选择一个算法;这是真正有机会可以作出一个巨大的改进的机会。需要做的就是深入思考你的问题的并行度是什么？

**Optimize **优化，方法就是多做测试，而不仅仅是猜什么会运行的更好，什么不会.在测试中找出算法的瓶颈，而不是花费大量的时间去优化不是瓶颈的kernel
**Deploy **常常部署，哪怕是只有一点点改进也要常常做测试，以此来作出下一步的优化计划。
![图片](4.png)
![图片](5.png)

弄明白并行化这些代码要达到什么目标是非常重要的
![图片](6.png)弱缩放描述当你增加处理器时解决方案规模如何随着每个处理器的固定问题规模而改变
强缩放描述当你添加处理器来处理一个固定的总问题规模时，解决方案的时间如何改变。
比如若原先处理一个蛋白质折叠模拟问题耗时一小时，现在若一小时内能处理更多或更大的蛋白质，那么这就是若缩放。
如果仍然是这个蛋白质，但能将其耗时减少到10分钟，那么这就是强缩放。

![图片](7.png)
使用代码分析工具，这会返回各个函数的运行时间，让我们不再凭借直觉去做优化，直觉上我们可能能够感受到耗时最多的函数，但是对于耗时第二第三多的函数可能会让我们非常吃惊;可使用的工具有gprof,VTune,VerySleepy.在你对最多耗时的函数做了并行化后，我们需要接着对第二第三的都做并行化，因为原先的bottleneck现在可能已经不再是瓶颈了。

用deviceQuery 查询GPU的峰值带宽，然后对比程序的带宽（计算所占比例），若带宽的占用率很低，意味着我们的内存访问效率很低，可能在程序中存在很多不可合并的内存访问任务。最常用的方式是合并访问内存。


int i = blockIdx.x*blockDim.x+threadIdx.x;
int i = blockIdx.y*blockDim.y+threadIdx.y;
out[j+N*i]=in[i+N*j]在这个表达式中，等号右边读取的是内存中的连续区域;而等号左边，每个线程读取的则是在内存中间隔为1024的存储区域


summary
APOD尽快的进行代码分析，并据此进行代码优化，尽早的让代码跑通，不要空想
measure & improve memory bandwidth;将自己的性能与理论峰值带宽相比较
* 保证足够的占用率，确保有足够的线程保持SM忙碌
* 合并全局内存存取，努力看能不能找到某种方式实现内存合并访问，如果不行，考虑转置操作，或者通过先前的一次很差的内存访问将数据放入内存，便于后续的访问能得到合并
* 最小化延迟。让线程同步的时间越少越好

![图片](8.png)
minimize thread divergence最小化线程发散
![图片](9.png)
当程序运行的时间瓶颈在计算，而不是数据复制和移动的时间时，还要考虑使用快速数学运算
__sin();__cos()等运算速度会快，虽然精度会比math.h中的函数低。
不要随便使用双精度浮点数据，在数字后面加上f表示这是一个单精度的运算3.14！=3.14f

如果受主机设备内存传输时间的限制，考虑使用stream和asynchronous memcpys来实现计算和内存拷贝的重叠


