---
title: 高性能CUDA应用设计与开发——读书笔记（第二章）
date: 2018-01-13 18:55:09
categories: 读书笔记
tags: [高性能计算,CUDA]
---
## 第二章：CUDA在机器学习与优化中的应用

> 主要内容

* 精通CUDA的编程者应该如何为建模与数据挖掘做出巨大贡献
* 机器学习技术，以及XOR问题对于计算通用设备的重要性
* C++仿函数

<!--more-->

### 建模与模拟

**数学模型**：对现实的抽象，用来对现实进行分析与预测。
**数值模拟**：通过应用程序将数学模型映射到电脑上。

******

### 常用的两个建模方法：

1. 基于第一性原理分析以及其他方法的人工推导模型

>   “第一性原理”是一个量子力学中的一个术语，意思是从头算，只采用最基本的事实，然后根据事实推论。

2. 基于数据拟合的参数化模型

>   与人工推导模型相比，经过数据计算推导出的模型相对容易建立。许多现有方法可以建立精确的模型得到很好的推广。使用数据来拟合模型是一个代价高昂的计算过程，并行计算依靠于处理单元数量密切相关的因素来缩减运行时间。对显现非线性特征的系统进行建模时，因为非线性系统不会对输入刺激做出线性回应，这意味着不能仅仅根据输入或者系统刺激的线性组合来建模。

### 机器学习与神经网络
>   人工神经网络(ANN)是一种基于观察到的数据推测函数的机器学习技术。ANN能够响应并适应复杂的、不可预见的刺激，并执行分类任务。训练ANN可以表示为寻找并确定最优网络参数(如：网络权重)减少初始数据集上的误差的优化问题。拟合过程中需要使用不同的参数集合重复的调用目标函数，计算训练数据中的每个样本。每个目标函数评估的运行时间为O(num_of_param*num_of_data)多数情况下参数的数量相对于训练数据的尺寸是较小的，这表明运行时间是由数据集合的尺寸决定的。训练过程中神经网络试图使多维曲面拟合训练数据，但 [维数灾难](http://blog.csdn.net/mydear_11000/article/details/51542984) 告诉我们，需要搜索、采样、建模的空间大小随着数据的位数呈现指数型增长。即使是稀疏采样，光滑的高维度曲面任然需要许多数据点。

没有隐藏单元的网络无法记忆异或逻辑，有隐藏单元的网络可以实现任意的布尔功能。关于这个问题吴恩达的机器学习课程中做了详细的解释，详见博客：
1. [Stanford机器学习笔记-4. 神经网络Neural Networks (part one)](https://www.cnblogs.com/llhthinker/p/5355987.html#autoid-1-3-0).
2. [【机器学习】神经网络实现异或（XOR）](https://www.cnblogs.com/Belter/p/6711160.html)

### 目标函数示例

>  thrust::transform_reduce模板使得目标函数的实现变得直接简单。一个ANN至少意味着二次目标函数：需要定义一个变换算子来计算神经网络在训练数据中每个样本上产生误差的而二次幂，然后用规约操作计算误差的平方和。   Thrust使用仿函数来执行变换、规约以及其他的一般方法。在C++中仿函数需要重载`

#### 仿函数

简单来说，仿函数就是重载()运算符的struct或class，利用对象支持operator()的特性，达到模拟函数调用效果的技术。简单说就是语法上和函数一样，用起来也跟函数一样，但是它不是函数。比如
`int add(int a, int b) { return a + b; }`
你也可以
`struct Add { int operator()(int a, int b) { return a + b; } };`
之后就可以声明一个这个类实例：`Add add;`
然后就和上面那个add一样用了：`int x = add(1, 2);`好处是里面可以带有一些自己的状态。
传统情况下一个函数要有状态，就是里面用static声明变量，不然就只能送一个结构体指针进来，在那个结构体里保存状态。但是现在，因为它不是函数了，它是对象，对象可以有成员变量，于是这些成员变量就用来保存状态。比如你一个仿函数，目的是给参数加上一个固定的数然后返回：

```
struct Add {
 int x;
 Add(int p) 
 { 
    x = p; 
 } 
 int operator()(int a) { return a + x; } 
 };
```

然后声明一个对象`Add add(5);`之后就可以`int x = add(2);`想想看如果是让你写一个函数实现这功能，怎么办……要用add(2)这样的语法调用，而且还要让它加的是5而不是其他什么数字，写不出来吧……

#### 内联函数
详见[内联函数简介](http://blog.csdn.net/u011327981/article/details/50601800)。我们在编写代码时，将功能封装成函数有很多好处：

① 阅读和理解函数 max 的调用，要比读一条等价的条件表达式并解释它的含义要容易得多
② 如果需要做任何修改，修改函数要比找出并修改每一处等价表达式容易得多
③ 使用函数可以确保统一的行为，每个测试都保证以相同的方式实现
④ 函数可以重用，不必为其他应用程序重写代码

> 虽然有这么多好处，但是写成函数有一个潜在的缺点：调用函数比求解等价表达式要慢得多。在大多数的机器上，调用函数都要做很多工作：调用前要先保存寄存器，并在返回时恢复，复制实参，程序还必须转向一个新位置执行。内联函数虽有好处，但是也要慎用，它以代码拷贝为代价，仅仅省去了函数调用的开销，这里的"调用开销"仅仅只参数压栈、跳转、退栈、返回等操作，如果执行函数体的开销比函数调用的开销大很多，那么内联的收益就会很小。
