---
title: 有序向量的查找
date: 2018-02-22 12:10:35
tags: 算法
---

常用的有序向量的查找有，二分查找，Fibonacci查找，插值查找。
查找接口的要求：
* 当有多个元素命中时，保证返回秩最大的
* 当查找失败时，能够返回失败的位置
<!--more-->
只有满足上述要求，才能够将计算结果不浪费，为其他功能提供接口。
```
// 二分查找算法（版本A）：在有序向量的区间[lo, hi)内查找元素e，0 <= lo <= hi <= _size
template <typename T> static Rank binSearch ( T* A, T const& e, Rank lo, Rank hi ) 
{
  /*DSA*/printf ( "BIN search (A)\n" );
   while ( lo < hi ) 
   {        
      //每步迭代可能要做两次比较判断，有三个分支
      Rank mi = ( lo + hi ) >> 1; //以中点为轴点
      if      ( e < A[mi] ) hi = mi; //深入前半段[lo, mi)继续查找
      else if ( A[mi] < e ) lo = mi + 1; //深入后半段(mi, hi)继续查找
      else    return mi; //在mi处命中
   } //成功查找可以提前终止
   return -1; //查找失败
```
} //有多个命中元素时，不能保证返回秩最大者；查找失败时，简单地返回-1，而不能指示失败的位置


![图片](1.png)![图片](2.png)![图片](3.png)
```
// 二分查找算法（版本B）：在有序向量的区间[lo, hi)内查找元素e，0 <= lo <= hi <= _size
template <typename T> static Rank binSearch ( T* A, T const& e, Rank lo, Rank hi ) {
   /*DSA*/printf ( "BIN search (B)\n" );
   while ( 1 < hi - lo ) 
   { 
      //每步迭代仅需做一次比较判断，有两个分支；成功查找不能提前终止
      Rank mi = ( lo + hi ) >> 1; //以中点为轴点
      ( e < A[mi] ) ? hi = mi : lo = mi; //经比较后确定深入[lo, mi)或[mi, hi)
   } //出口时hi = lo + 1，查找区间仅含一个元素A[lo]
   return ( e == A[lo] ) ? lo : -1 ; //查找成功时返回对应的秩；否则统一返回-1
```
} //有多个命中元素时，不能保证返回秩最大者；查找失败时，简单地返回-1，而不能指示失败的位置


```
// 二分查找算法（版本C）：在有序向量的区间[lo, hi)内查找元素e，0 <= lo <= hi <= _size
template <typename T> static Rank binSearch ( T* A, T const& e, Rank lo, Rank hi ) {
   /*DSA*/printf ( "BIN search (C)\n" );
   while ( lo < hi ) 
   {
      //每步迭代仅需做一次比较判断，有两个分支
      Rank mi = ( lo + hi ) >> 1; //以中点为轴点
      ( e < A[mi] ) ? hi = mi : lo = mi + 1; //经比较后确定深入[lo, mi)或(mi, hi)
   } //成功查找不能提前终止
   return --lo; //循环结束时，lo为大于e的元素的最小秩，故lo - 1即不大于e的元素的最大秩
} //有多个命中元素时，总能保证返回秩最大者；查找失败时，能够返回失败的位置
```
![图片](4.png)

二分查找的时间复杂度为log(n), Fibonacci查找是二分查找中的一种特殊情况，它与一般的二分查找的区别就在于中间点mid的选择，二分查找是取整个向量长度的中间值，而Fibonacci是取向量的黄金分割点。这对于查找时向左边走和向右边走比较次数不一样的一般的二分查找来说，可以尽可能的避免向右边走（查找两次）的情况。
插值查找适用于在一定范围内均匀随机分布的数组，它的时间复杂度可以降低至log(log(n)).对于我们一般处理的向量来说log(n)已经足够了，哪怕是一个2^32个元素的向量也仅仅需要进行32次查找，再取对数也就是5，所以用插值查找优势并不是很明显，而且二分查找和Fibonacci查找都只会用到加法和减法，而插值查找由于要计算比例会用到乘法和除法，指令级别的计算时间就提上去了。所以，插值查找更擅长在比较大的宏观的范围内将问题的关注点尽可能快的缩小到一定的范围，换句话说，比较擅长处理极大的情况。一旦到了比较小的情况，因为它要用到乘法除法，以及容易受到局部小的扰动，这些都是overhead额外计算，额外计算占比就不可忽视，此时二分查找的优势就体现出来了。
![图片](5.png)![图片](6.png)
综上所述：将各种查找算法的有点相结合。
首先通过插值查找，将查找范围缩小到一定的范围，然后再进行二分查找或者顺序查找。


