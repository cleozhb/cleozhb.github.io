---
title: 起泡排序
date: 2019-01-05 12:32:28
tags: [排序, 算法]
---

首先说明，无论如何改进，最坏情况下，起泡排序的时间复杂度仍然为O(n2)
一般而言起泡排序的时间复杂度是O(n2)，机械的从头到尾的扫描。整体运行时间可以用整个三角形的面积来表示。
![图片](1.png)

<!--more-->

第一版改进，与原始版本的不同之处在于添加了一个标志，来记录if语句是否成立过。首先认为是有序的，一旦发现逆序元素，就将其标志为true，这反映了这一趟扫描中是否发现了逆序对。这个标志作为返回值，在主程序中作为while循环的控制条件。计算量就变为下面这个梯形，判定有序之后及时终止。
![图片](2.png)
```
template <typename T> //向量的起泡排序
void Vector<T>::bubbleSort ( Rank lo, Rank hi ) //assert: 0 <= lo < hi <= size
{ while ( !bubble ( lo, hi-- ) ); } //逐趟做扫描交换，直至全序
template <typename T> bool Vector<T>::bubble ( Rank lo, Rank hi ) { //一趟扫描交换
   bool sorted = true; //整体有序标志
   while ( ++lo < hi ) //自左向右，逐一检查各对相邻元素
      if ( _elem[lo - 1] > _elem[lo] ) { //若逆序，则
         sorted = false; //意味着尚未整体有序，并需要
         swap ( _elem[lo - 1], _elem[lo] ); //通过交换使局部有序
      }
   return sorted; //返回有序标志
}
```

在新一版的改进中，记录的不再是一个逻辑变量，而是一个名为last的整形，表示最后发生交换的元素的秩。初始值为lo，在整个程序中lo这个变量是持续递增的，不会发生减少。
在程序运行的过程中，可能会发现一部分已经有序了。这种情况可能会多次出现，即使最初的向量是无序的，在进行若干次扫描之后，区间的某个后缀已经完全有序了，这时候就可以聪明的跳过有序的部分。
![图片](3.png)![图片](4.png)
这样的若干个梯形，比之前的版本划分更加精细，节省的时间应该更多。

```
template <typename T> //向量的起泡排序
void Vector<T>::bubbleSort ( Rank lo, Rank hi ) //assert: 0 <= lo < hi <= size
{ while ( lo < ( hi = bubble ( lo, hi ) ) ); } //逐趟做扫描交换，直至全序

template <typename T> Rank Vector<T>::bubble ( Rank lo, Rank hi ) { //一趟扫描交换
   Rank last = lo; //最右侧的逆序对初始化为[lo - 1, lo]
   while ( ++lo < hi ) //自左向右，逐一检查各对相邻元素
      if ( _elem[lo - 1] > _elem[lo] ) { //若逆序，则
         last = lo; //更新最右侧逆序对位置记录，并
         swap ( _elem[lo - 1], _elem[lo] ); //通过交换使局部有序
      }
   return last; //返回最右侧的逆序对位置
}

```

