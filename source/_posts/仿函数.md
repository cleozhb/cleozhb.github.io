---
title: 仿函数
date: 2018-06-21 20:26:40
tags: [仿函数,c++]
---
### 概念
函数(functor)又称之为函数对象（function object），其实就是重载了operator（）操作符的struct或class，没有什么特别的地方。仿函数(functor)使一个类的使用看上去象一个函数，这个类就有了类似函数的行为，就是一个仿函数类了。 
如下面的代码定义了一个二元的仿函数（有两个参数）：
```
struct IntLess
{
    bool operator()(int _left, int _right) const
    {
        return _left<_right;
    }
}
```

<!--more-->

### 为什么要使用仿函数
        1）仿函数比一般的函数灵活。        
        2）仿函数有类型识别，可以作为模板参数。
        3）执行速度上仿函数比函数和指针要更快的。

### 怎么使用仿函数
        
除了在stl里，别的地方你很少会看到仿函数的身影。而在stl里仿函数最常用的就是作为函数的参数，或者模板的参数。在stl里有自己预定义的仿函数，比如所有的运算符，=，-，*，/，比如比较符号<、>、<=、>=等。stl中的'<'仿函数是less：
```
// TEMPLATE STRUCT less
template<class _Ty>
    struct less : public binary_function<_Ty, _Ty, bool>
    {   // functor for operator<
    bool operator()(const _Ty& _Left, const _Ty& _Right) const
        {   // apply operator< to operands
        return (_Left < _Right);
        }
    };
// TEMPLATE STRUCT greater
template<class _Ty>
    struct greater
        : public binary_function<_Ty, _Ty, bool>
    {   // functor for operator>
    bool operator()(const _Ty& _Left, const _Ty& _Right) const
        {   // apply operator> to operands
        return (_Left > _Right);
        }
    };
```
### 例子
```
//Person.h
#include <string>
using namespace std;
class Person
{
public:
    Person();
    //~Person();
    Person(string _firstname, string _lastname)
    {
        this->FirstName = _firstname;
        this->LastName = _lastname;
    };
public:
    string FirstName;
    string LastName;
    // additional information
};

class PersonCriterion
{
public:
    bool operator()(const Person& p1, const Person& p2)
    {
        return p1.LastName < p2.LastName ||(!(p2.LastName<p1.LastName) && p1.FirstName<p2.FirstName);
    }
};

//main.cpp
#include <iostream>
#include <set>
#include "Person.h"
using namespace std;
int main( int argc, char* argv[])
{
    set<Person, PersonCriterion> colls;
    colls.insert(Person("Tom","James"));
    colls.insert(Person("Mike","James"));
    colls.insert(Person("Jane","Bush"));
    colls.insert(Person("Bill","Gates"));

    std::set<Person, PersonCriterion>::iterator iter;
    for ( iter = colls.begin(); iter!=colls.end(); ++iter)
    {       
        Person p = (Person)(*iter);     

        cout<< p.FirstName<<"  "<<p.LastName<<endl;
    }       
//  getchar();
    return 1;
}
```
在上面的例子中，定义了一个Person类，包含2个成员变量FirstName和LastName，并定义了一个PersonCriterion类来对Person进行排序。PersonCriterion定义了一个operator()用于比较两个人的姓，如果姓相等，再比较其名。这样coll的构造函数就会自动产生PersonCriterion的一个实体，并将所有的元素按此进行排序。
        注意，在这里PersonCriterion是一个类，我们把它作为set的template参数，而一般的函数却不能做到这一点，进一步凸显了仿函数的优势。
![图片](1.png)
STL大致分为六大模块：容器（container），算法（algorithm），迭代器（iterator），仿函数（functor），配接器（adapter），配置器（allocator）。其中仿函数是体积最小，观念最简单，但是在stl算法的搭配中起到了非常重要的作用。
在map中以map<Key, Data, Compare, Alloc>声明一个map，例如：
map<int, int, less<int>, Alloc<int> > intmap;所以只要通过第三个参数compare将比较模板类传入即可实现自定义的比较方式，覆盖默认的less。
### 参考
深入理解仿函数 [https://blog.csdn.net/kezunhai/article/details/38514099](https://blog.csdn.net/kezunhai/article/details/38514099)
STL map和set的实现 [https://blog.csdn.net/heyutao007/article/details/6798802](https://blog.csdn.net/heyutao007/article/details/6798802)
STL仿函数实现详解 [https://blog.csdn.net/u010710458/article/details/79734558](https://blog.csdn.net/u010710458/article/details/79734558)
