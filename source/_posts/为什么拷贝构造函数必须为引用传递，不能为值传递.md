---
title: 为什么拷贝构造函数必须为引用传递，不能为值传递
date: 2018-04-11 20:49:25
tags: c++
---

参数为引用，不为值传递是为了防止拷贝构造函数的无线递归，最终导致栈溢出。
```
#include <iostream>
#include <cstdlib>
#include <stdio.h>
using namespace std;
class test
{
public:
    test()
    {
      cout<<"constructor with argument"<<endl;
    }
    test(test&t)    
    {
      cout<<"copy constructor\n";
    }
    test&operator=(const test&e)
    {
      cout<<"assignment operator\n";
      return *this;
    }
};
int main(int argc,char* argv[])
{
  test ort;
  test a(ort);
  test b = ort;
  a = b;
  return 0;
}
```

<!--more-->

![图片](1.png)
上述运行结果可知，test a(ort)与test b = ort都调用的是拷贝构造函数，不可被 = 误导为test b = ort会调用赋值构造函数。只有最后的a = b调用了赋值构造函数。
如果复制构造函数改为用值传递而不是引用传递，编译器会报错。这是因为如果允许复制构造函数传值，就会在复制构造函数内调用复制构造函数，就会造成无休止的递归调用从而导致栈溢出。

如果将赋值构造函数改为值传递即 test& operator=(const test e)
测试结果如下![图片](2.png)
仅仅是多了一次拷贝，不会无限递归。总结:拷贝构造函数的参数必须为引用。赋值构造函数参数既可以为引用，也可以为值传递，值传递会多一次拷贝。因此建议赋值构造函数建议也写为引用类型。

### 参考
[http://www.cnblogs.com/chengkeke/p/5417362.html](http://www.cnblogs.com/chengkeke/p/5417362.html)