---
title: 并查集
date: 2018-03-28 16:31:00
categories: 算法
tags: [并查集, 算法]
---
## 并查集的原理及应用
> 主要内容

* 并查集定义、性质
* Find()与join()
* 应用例题1[http://acm.hdu.edu.cn/showproblem.php?pid=1232](http://acm.hdu.edu.cn/showproblem.php?pid=1232)
* 应用例题2[https://blog.csdn.net/The_best_man/article/details/62418823](https://blog.csdn.net/The_best_man/article/details/62418823)
<!--more-->

### 定义

见到的讲的很好的一篇并查集的文章[一个很有意思的并查集详解](https://blog.csdn.net/u013546077/article/details/64509038)

### 例题1

#### Problem Description

```
某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？ 
```

#### Input

```
测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是城镇数目N ( < 1000 )和道路数目M；随后的M行对应M条道路，每行给出一对正整数，分别是该条道路直接连通的两个城镇的编号。为简单起见，城镇从1到N编号。 
注意:两个城市之间可以有多条道路相通,也就是说
3 3
1 2
1 2
2 1
这种输入也是合法的
当N为0时，输入结束，该用例不被处理。 
```

#### output

对每个测试用例，在1行里输出最少还需要建设的道路数目。 

#### Sample Input

```
4 2
1 3
4 3
3 3
1 2
1 3
2 3
5 2
1 2
3 5
999 0
0
```

#### Sample Output
```
1
0
2
998
```

#### 用并查集的解法
```
// bingchaji.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
using namespace std;

int pre[1000 ];

int find(int x)

{
    int r = x;
    while (pre[r] != r)
        r = pre[r];
    int i = x; int j;
    while (i != r)
    {
        j = pre[i];
        pre[i] = r;
        i = j;
    }
    return r;
}

int main()
{
    int n, m, p1, p2, i, total, f1, f2;
    while (scanf_s("%d", &n) && n)         //读入n，如果n为0，结束
    {   //刚开始的时候，有n个城镇，一条路都没有 //那么要修n-1条路才能把它们连起来
        total = n - 1;
        //每个点互相独立，自成一个集合，从1编号到n //所以每个点的上级都是自己
        for (i = 1; i <= n; i++) 
        {
            pre[i] = i; 
        }   
        //共有m条路
        scanf_s("%d", &m); 
        while (m--)
        {   //下面这段代码，其实就是join函数，只是稍作改动以适应题目要求
            //每读入一条路，看它的端点p1，p2是否已经在一个连通分支里了
            scanf_s("%d %d", &p1, &p2);
            f1 = find(p1);
            f2 = find(p2);
            //如果是不连通的，那么把这两个分支连起来
            //分支的总数就减少了1，还需建的路也就减了1
            if (f1 != f2)
            {
                pre[f2] = f1;
                total--;
            }
            //如果两点已经连通了，那么这条路只是在图上增加了一个环 //对连通性没有任何影响，无视掉
        }
        //最后输出还要修的路条数
        printf("%d\n", total);
    }
    return 0;
}

```


### 例题2

#### Problem Description

```
标题：风险度量

X星系的的防卫体系包含 n 个空间站。这 n 个空间站间有 m 条通信链路，构成通信网。 
两个空间站间可能直接通信，也可能通过其它空间站中转。

对于两个站点x和y (x != y), 如果能找到一个站点z，使得： 
当z被破坏后，x和y无法通信，则称z为关于x,y的关键站点。

显然，对于给定的两个站点，关于它们的关键点的个数越多，通信风险越大。

你的任务是：已知网络结构，求两站点之间的通信风险度，即：它们之间的关键点的个数。
```

#### Input

```
输入数据第一行包含2个整数n(2 <= n <= 1000), m(0 <= m <= 2000),分别代表站点数，链路数。 
空间站的编号从1到n。通信链路用其两端的站点编号表示。 
接下来m行，每行两个整数 u,v (1 <= u, v <= n; u != v)代表一条链路。 
最后1行，两个数u,v，代表被询问通信风险度的两个站点。  
```

#### output

一个整数，如果询问的两点不连通则输出-1. 

#### Sample Input

```
7 6 
1 3 
2 3 
3 4 
3 5 
4 5 
5 6 
1 6 
```

#### Sample Output
```
2
```


### 参考文献
1. [并查集(Union-Find)算法介绍](https://blog.csdn.net/dm_vincent/article/details/7655764)
2. [并查集(Union-Find) 应用举例 --- 基础篇](https://blog.csdn.net/dm_vincent/article/details/7769159)
3. [OpenCV_连通区域分析与标记（Connected Component Analysis-Labeling）
](http://www.52ml.net/1103.html)
